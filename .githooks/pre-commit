#!/usr/bin/env zsh
#
# Ralph Pre-Commit Hook
# Runs syntax checks, linting, and custom pattern analysis before each commit.
#
# Install: git config core.hooksPath .githooks
# Or run: ./scripts/setup-hooks.sh
#

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo "${BLUE}  ğŸ” Ralph Pre-Commit Checks${NC}"
echo "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""

ERRORS=0
WARNINGS=0

# Get list of staged .zsh files
STAGED_ZSH_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.zsh$' || true)
REPO_ROOT=$(git rev-parse --show-toplevel)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1-5. ZSH FILE CHECKS (only when .zsh files are staged)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if [[ -z "$STAGED_ZSH_FILES" ]]; then
  echo "${GREEN}âœ“ No .zsh files staged, skipping syntax/lint checks (1-5)${NC}"
  echo ""
else
  echo "Checking files: $STAGED_ZSH_FILES"
  echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 1. ZSH SYNTAX CHECK
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  echo "${YELLOW}[1/8] ZSH Syntax Check${NC}"

  for file in ${(f)STAGED_ZSH_FILES}; do
    if zsh -n "$file" 2>&1; then
      echo "  ${GREEN}âœ“${NC} $file"
    else
      echo "  ${RED}âœ—${NC} $file has syntax errors"
      ERRORS=$((ERRORS + 1))
    fi
  done
  echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 2. SHELLCHECK (for .sh files only - doesn't support zsh)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  echo "${YELLOW}[2/8] ShellCheck Linting${NC}"

  # ShellCheck doesn't support zsh (SC1071), so we only run it on .sh files
  # The zsh syntax check in step 1 is sufficient for .zsh files

  # Get staged .sh files
  STAGED_SH_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.sh$' || true)

  if [[ -z "$STAGED_SH_FILES" ]]; then
    echo "  ${GREEN}âœ“${NC} No .sh files staged"
    echo "  Note: .zsh files use zsh -n for syntax checking (step 1)"
  elif ! command -v shellcheck &> /dev/null; then
    echo "  ${YELLOW}âš ${NC} shellcheck not installed - skipping .sh file linting"
    echo "  Install with: brew install shellcheck"
    WARNINGS=$((WARNINGS + 1))
  else
    for file in ${(f)STAGED_SH_FILES}; do
      # Run shellcheck with common exclusions
      # SC1091: Not following sourced file (can't resolve paths)
      # SC2034: Variable appears unused (common in sourced files)
      if shellcheck -e SC1091,SC2034 "$file" 2>&1; then
        echo "  ${GREEN}âœ“${NC} $file"
      else
        echo "  ${RED}âœ—${NC} $file has shellcheck warnings/errors"
        ERRORS=$((ERRORS + 1))
      fi
    done
  fi
  echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 3. CUSTOM PATTERN CHECKS (Bug Prevention)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  echo "${YELLOW}[3/8] Custom Bug Pattern Checks${NC}"

  for file in ${(f)STAGED_ZSH_FILES}; do
    FILE_ERRORS=0

    # Check 1: break/continue outside of loop control structures
    # This catches the bug where 'break' was outside if-else in retry logic
    if grep -n 'break$' "$file" | while read line; do
      linenum=$(echo "$line" | cut -d: -f1)
      # Get context: 5 lines before
      context=$(sed -n "$((linenum-5)),$((linenum))p" "$file")
      # Check if break is properly inside a conditional or case
      if ! echo "$context" | grep -qE '(if|else|then|case|esac|\{)'; then
        echo "  ${RED}âœ—${NC} $file:$linenum - 'break' may be outside conditional block"
        FILE_ERRORS=$((FILE_ERRORS + 1))
      fi
    done; [[ $FILE_ERRORS -gt 0 ]]; then
      ERRORS=$((ERRORS + FILE_ERRORS))
    fi

    # Check 2: Using $? after a command that might overwrite it
    if grep -nE '\|\s*tee.*\n.*\$\?' "$file" 2>/dev/null | head -1 | grep -q .; then
      echo "  ${YELLOW}âš ${NC} $file - Using \$? after pipe may capture wrong exit code (use \${pipestatus[1]})"
      WARNINGS=$((WARNINGS + 1))
    fi

    # Check 3: Unquoted variable expansions in conditionals
    # Note: In zsh [[ ]], unquoted variables are safe (no word splitting/globbing)
    # Only flag string comparisons with = or ==, not numeric -eq/-lt/-gt
    if grep -nE '\[\[.*\$[a-zA-Z_][a-zA-Z0-9_]*\s*(=|==)\s*[^"$]' "$file" 2>/dev/null | head -3 | grep -q .; then
      echo "  ${YELLOW}âš ${NC} $file - Unquoted variable in string comparison (consider quoting)"
      WARNINGS=$((WARNINGS + 1))
    fi

    # Check 4: eval usage (potential security issue)
    # Only flag actual eval commands, not comments mentioning eval
    if grep -n '^\s*eval\b\|;\s*eval\b' "$file" 2>/dev/null | head -1 | grep -q .; then
      echo "  ${YELLOW}âš ${NC} $file - Uses 'eval' - consider using array expansion instead"
      WARNINGS=$((WARNINGS + 1))
    fi

    # Check 5: Hardcoded sleep values > 30s (might indicate forgotten debug code)
    if grep -nE 'sleep\s+[3-9][0-9]|sleep\s+[0-9]{3,}' "$file" 2>/dev/null | head -1 | grep -q .; then
      echo "  ${YELLOW}âš ${NC} $file - Long sleep detected (>30s) - is this intentional?"
      WARNINGS=$((WARNINGS + 1))
    fi

    # Check 6: TODO/FIXME/HACK/XXX comments
    if grep -niE '(TODO|FIXME|HACK|XXX):?' "$file" 2>/dev/null | head -3 | grep -q .; then
      echo "  ${YELLOW}âš ${NC} $file - Contains TODO/FIXME comments (non-blocking)"
      WARNINGS=$((WARNINGS + 1))
    fi

    if [[ $FILE_ERRORS -eq 0 ]]; then
      echo "  ${GREEN}âœ“${NC} $file - no critical patterns found"
    fi
  done
  echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 4. RETRY LOGIC INTEGRITY CHECK
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  echo "${YELLOW}[4/8] Retry Logic Integrity${NC}"

  for file in ${(f)STAGED_ZSH_FILES}; do
    # Check that retry loops have proper structure
    if grep -q 'while.*retry' "$file" 2>/dev/null; then
      # Ensure there's a continue in the retry logic
      if ! grep -qE 'continue\s*$' "$file" 2>/dev/null; then
        echo "  ${RED}âœ—${NC} $file - Retry loop found but no 'continue' statement"
        ERRORS=$((ERRORS + 1))
      fi

      # Ensure max_retries is defined
      if ! grep -q 'max_retries' "$file" 2>/dev/null; then
        echo "  ${RED}âœ—${NC} $file - Retry loop found but no 'max_retries' defined"
        ERRORS=$((ERRORS + 1))
      fi

      # Ensure retry_count is incremented
      if ! grep -qE 'retry_count=.*\+' "$file" 2>/dev/null; then
        echo "  ${RED}âœ—${NC} $file - Retry loop found but retry_count not incremented"
        ERRORS=$((ERRORS + 1))
      fi

      if [[ $ERRORS -eq 0 ]]; then
        echo "  ${GREEN}âœ“${NC} $file - retry logic structure looks correct"
      fi
    else
      echo "  ${GREEN}âœ“${NC} $file - no retry logic to check"
    fi
  done
  echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 5. FUNCTION BALANCE CHECK
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  echo "${YELLOW}[5/8] Brace/Bracket Balance${NC}"

  for file in ${(f)STAGED_ZSH_FILES}; do
    # Count opening and closing braces (important for function definitions)
    OPEN_BRACES=$(grep -o '{' "$file" | wc -l | tr -d ' ')
    CLOSE_BRACES=$(grep -o '}' "$file" | wc -l | tr -d ' ')

    if [[ "$OPEN_BRACES" -ne "$CLOSE_BRACES" ]]; then
      # Braces are critical - error
      echo "  ${RED}âœ—${NC} $file - Unbalanced braces: { = $OPEN_BRACES, } = $CLOSE_BRACES"
      ERRORS=$((ERRORS + 1))
    else
      echo "  ${GREEN}âœ“${NC} $file - braces balanced"
    fi

    # Parentheses often appear in regex/strings - warn only, don't block
    OPEN_PARENS=$(grep -o '(' "$file" | wc -l | tr -d ' ')
    CLOSE_PARENS=$(grep -o ')' "$file" | wc -l | tr -d ' ')
    PAREN_DIFF=$((OPEN_PARENS - CLOSE_PARENS))
    PAREN_DIFF=${PAREN_DIFF#-}  # absolute value

    if [[ "$PAREN_DIFF" -gt 5 ]]; then
      # Only warn if difference is significant (>5 indicates likely real issue)
      echo "  ${YELLOW}âš ${NC} $file - Parentheses imbalance: ( = $OPEN_PARENS, ) = $CLOSE_PARENS (may be regex/strings)"
      WARNINGS=$((WARNINGS + 1))
    fi
  done
  echo ""
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 6. JSON SCHEMA VALIDATION (always runs)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo "${YELLOW}[6/8] JSON Schema Validation${NC}"

# Check for staged JSON files in schemas/
STAGED_JSON_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.json$' || true)

if [[ -z "$STAGED_JSON_FILES" ]]; then
  echo "  ${GREEN}âœ“${NC} No JSON files staged"
else
  for file in ${(f)STAGED_JSON_FILES}; do
    if jq '.' "$file" > /dev/null 2>&1; then
      echo "  ${GREEN}âœ“${NC} $file - valid JSON"
    else
      echo "  ${RED}âœ—${NC} $file - invalid JSON syntax"
      ERRORS=$((ERRORS + 1))
    fi
  done
fi
echo ""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 7. TEST SUITE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo "${YELLOW}[7/8] Test Suite${NC}"

# Run ralph tests
TEST_SCRIPT=""
if [[ -f "$REPO_ROOT/tests/test-ralph.zsh" ]]; then
  TEST_SCRIPT="$REPO_ROOT/tests/test-ralph.zsh"
elif [[ -f "$HOME/.config/ralphtools/tests/test-ralph.zsh" ]]; then
  TEST_SCRIPT="$HOME/.config/ralphtools/tests/test-ralph.zsh"
fi

if [[ -n "$TEST_SCRIPT" && -x "$TEST_SCRIPT" ]]; then
  echo "  Running ralph tests..."
  echo ""

  # Capture test output and exit code
  TEST_OUTPUT=$("$TEST_SCRIPT" 2>&1) || TEST_EXIT_CODE=$?
  TEST_EXIT_CODE=${TEST_EXIT_CODE:-0}

  # Show output (tests have their own formatting)
  echo "$TEST_OUTPUT"

  if [[ $TEST_EXIT_CODE -ne 0 ]]; then
    echo ""
    echo "  ${RED}âœ— Ralph tests failed${NC}"
    ERRORS=$((ERRORS + 1))
  else
    echo "  ${GREEN}âœ“${NC} Ralph tests passed"
  fi
else
  echo "  ${YELLOW}âš ${NC} test-ralph.zsh not found - skipping ralph tests"
  WARNINGS=$((WARNINGS + 1))
fi

# Run skills tests
SKILLS_TEST_SCRIPT=""
if [[ -f "$REPO_ROOT/tests/test-skills.zsh" ]]; then
  SKILLS_TEST_SCRIPT="$REPO_ROOT/tests/test-skills.zsh"
fi

if [[ -n "$SKILLS_TEST_SCRIPT" && -x "$SKILLS_TEST_SCRIPT" ]]; then
  echo ""
  echo "  Running skills tests..."
  echo ""

  # Capture test output and exit code
  SKILLS_TEST_OUTPUT=$("$SKILLS_TEST_SCRIPT" 2>&1) || SKILLS_TEST_EXIT_CODE=$?
  SKILLS_TEST_EXIT_CODE=${SKILLS_TEST_EXIT_CODE:-0}

  # Show output (tests have their own formatting)
  echo "$SKILLS_TEST_OUTPUT"

  if [[ $SKILLS_TEST_EXIT_CODE -ne 0 ]]; then
    echo ""
    echo "  ${RED}âœ— Skills tests failed${NC}"
    ERRORS=$((ERRORS + 1))
  else
    echo "  ${GREEN}âœ“${NC} Skills tests passed"
  fi
else
  echo "  ${YELLOW}âš ${NC} test-skills.zsh not found - skipping skills tests"
fi
echo ""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 8. AGENTS.MD SYNC (if modified)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo "${YELLOW}[8/8] AGENTS.md Sync${NC}"

# Check if AGENTS.md is staged for this commit
if git diff --cached --name-only | grep -q '^AGENTS\.md$'; then
  # Find sync-agents.sh (check common locations)
  SYNC_SCRIPT=""

  if [[ -f "$HOME/.config/ralphtools/scripts/sync-agents.sh" ]]; then
    SYNC_SCRIPT="$HOME/.config/ralphtools/scripts/sync-agents.sh"
  elif [[ -f "$REPO_ROOT/scripts/sync-agents.sh" ]]; then
    SYNC_SCRIPT="$REPO_ROOT/scripts/sync-agents.sh"
  fi

  if [[ -n "$SYNC_SCRIPT" && -x "$SYNC_SCRIPT" ]]; then
    echo "  ${GREEN}âœ“${NC} AGENTS.md modified - syncing to AI tool files..."
    "$SYNC_SCRIPT"
  else
    echo "  ${YELLOW}âš ${NC} sync-agents.sh not found - skipping AGENTS.md sync"
    WARNINGS=$((WARNINGS + 1))
  fi
else
  echo "  ${GREEN}âœ“${NC} AGENTS.md not modified - no sync needed"
fi
echo ""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SUMMARY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"

if [[ $ERRORS -gt 0 ]]; then
  echo "${RED}  âœ— COMMIT BLOCKED: $ERRORS error(s) found${NC}"
  echo "${YELLOW}  âš  $WARNINGS warning(s) (non-blocking)${NC}"
  echo ""
  echo "  Fix the errors above before committing."
  echo "  To bypass (not recommended): git commit --no-verify"
  echo "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  exit 1
elif [[ $WARNINGS -gt 0 ]]; then
  echo "${GREEN}  âœ“ COMMIT ALLOWED (with $WARNINGS warning(s))${NC}"
  echo "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  exit 0
else
  echo "${GREEN}  âœ“ ALL CHECKS PASSED${NC}"
  echo "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  exit 0
fi
